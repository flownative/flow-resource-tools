<?php
namespace Flownative\ResourceTools\ResourceManagement;

use Neos\Flow\Annotations as Flow;
use Neos\Flow\ResourceManagement\ResourceMetaDataInterface;
use Neos\Flow\ResourceManagement\Target\FileSystemSymlinkTarget;
use Neos\Flow\Security\Cryptography\HashService;
use Neos\Flow\Security\Exception\InvalidArgumentForHashGenerationException;

/**
 * A symlink target for the local filesystem that generates public paths based on salted
 * information about the file so that the public URI cannot be guessed even if you know
 * the file. (As long as the encryption key or salt are secret)
 *
 * Either uses the autogenerated encryption key or the "salt" option if configured.
 */
class SaltedFileSystemSymlinkTarget extends FileSystemSymlinkTarget
{
    /**
     * @Flow\Inject
     * @var HashService
     */
    protected $hashService;

    /**
     * Prepares a publication path with a salted hash that cannot be guessed by knowing the file alone.
     *
     * @param ResourceMetaDataInterface $object
     * @return string
     * @throws InvalidArgumentForHashGenerationException
     */
    protected function getRelativePublicationPathAndFilename(ResourceMetaDataInterface $object): string
    {
        if ($object->getRelativePublicationPath() !== '') {
            return $object->getRelativePublicationPath() . $object->getFilename();
        }

        $pathAndFilename = 's';
        $sha1Hash = $this->generateSaltedHash($object);

        if ($this->subdivideHashPathSegment) {
            $pathAndFilename .= $sha1Hash[0] . '/' . $sha1Hash[1] . '/' . $sha1Hash[2] . '/' . $sha1Hash[3] . '/' . $sha1Hash . '/' . $object->getFilename();
        } else {
            $pathAndFilename .= $sha1Hash . '/' . $object->getFilename();
        }

        return $pathAndFilename;

    }

    /**
     * Generates the salted hash based on the file
     *
     * @param ResourceMetaDataInterface $object
     * @return string
     * @throws InvalidArgumentForHashGenerationException
     */
    protected function generateSaltedHash(ResourceMetaDataInterface $object): string
    {
        $objectIdentificationString = $object->getSha1() . '~' . $object->getMediaType();
        if (empty($this->options['salt'])) {
           return $this->hashService->generateHmac($objectIdentificationString);
        }

        return hash_hmac('sha1', $objectIdentificationString, $this->options['salt']);
    }

    /**
     * @param string $key
     * @param mixed $value
     * @return bool
     */
    protected function setOption($key, $value): bool
    {
        if ($key === 'salt') {
            $this->options['salt'] = $value;
            return true;
        }
        return parent::setOption($key, $value);
    }

}
